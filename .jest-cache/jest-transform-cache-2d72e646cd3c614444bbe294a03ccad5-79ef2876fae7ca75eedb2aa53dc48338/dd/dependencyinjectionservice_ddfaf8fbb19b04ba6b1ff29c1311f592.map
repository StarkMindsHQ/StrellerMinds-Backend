{"file":"C:\\Users\\g-ekoh\\Desktop\\StrellerMinds-Backend\\src\\common\\services\\dependency-injection.service.ts","mappings":"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","names":[],"sources":["C:\\Users\\g-ekoh\\Desktop\\StrellerMinds-Backend\\src\\common\\services\\dependency-injection.service.ts"],"sourcesContent":["import { Injectable, Logger, Type, BadRequestException, ServiceUnavailableException } from '@nestjs/common';\r\nimport { ModuleRef } from '@nestjs/core';\r\n\r\n/**\r\n * Service for managing dependency injection and service resolution\r\n */\r\nexport interface ServiceResolutionError extends Error {\r\n  serviceName: string;\r\n  token?: string | symbol;\r\n  originalError: Error;\r\n}\r\n\r\n@Injectable()\r\nexport class DependencyInjectionService {\r\n  private readonly logger = new Logger(DependencyInjectionService.name);\r\n  private readonly serviceCache = new Map<string, any>();\r\n  private readonly cacheEnabled = true;\r\n  private readonly maxCacheSize = 100;\r\n\r\n  constructor(private readonly moduleRef: ModuleRef) {}\r\n\r\n  /**\r\n   * Get a service instance by type\r\n   */\r\n  async getService<T>(serviceType: Type<T>): Promise<T> {\r\n    const cacheKey = `type:${serviceType.name}`;\r\n    \r\n    // Check cache first\r\n    if (this.cacheEnabled && this.serviceCache.has(cacheKey)) {\r\n      this.logger.debug(`Service ${serviceType.name} found in cache`);\r\n      return this.serviceCache.get(cacheKey);\r\n    }\r\n\r\n    try {\r\n      const service = await this.moduleRef.get(serviceType, { strict: false });\r\n      \r\n      // Cache the service if caching is enabled\r\n      if (this.cacheEnabled) {\r\n        this.setCacheEntry(cacheKey, service);\r\n      }\r\n      \r\n      return service;\r\n    } catch (error) {\r\n      const serviceError: ServiceResolutionError = {\r\n        name: 'ServiceResolutionError',\r\n        message: `Failed to resolve service ${serviceType.name}: ${error.message}`,\r\n        serviceName: serviceType.name,\r\n        originalError: error,\r\n      };\r\n      \r\n      this.logger.error(`Failed to resolve service ${serviceType.name}: ${error.message}`);\r\n      throw new ServiceUnavailableException(serviceError.message, { cause: serviceError });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a service instance by token\r\n   */\r\n  async getServiceByToken<T>(token: string | symbol): Promise<T> {\r\n    const cacheKey = `token:${String(token)}`;\r\n    \r\n    // Check cache first\r\n    if (this.cacheEnabled && this.serviceCache.has(cacheKey)) {\r\n      this.logger.debug(`Service with token ${String(token)} found in cache`);\r\n      return this.serviceCache.get(cacheKey);\r\n    }\r\n\r\n    try {\r\n      const service = await this.moduleRef.get(token, { strict: false });\r\n      \r\n      // Cache the service if caching is enabled\r\n      if (this.cacheEnabled) {\r\n        this.setCacheEntry(cacheKey, service);\r\n      }\r\n      \r\n      return service;\r\n    } catch (error) {\r\n      const serviceError: ServiceResolutionError = {\r\n        name: 'ServiceResolutionError',\r\n        message: `Failed to resolve service by token ${String(token)}: ${error.message}`,\r\n        serviceName: String(token),\r\n        token,\r\n        originalError: error,\r\n      };\r\n      \r\n      this.logger.error(`Failed to resolve service by token ${String(token)}: ${error.message}`);\r\n      throw new ServiceUnavailableException(serviceError.message, { cause: serviceError });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if a service is available\r\n   */\r\n  async isServiceAvailable(serviceType: Type<any>): Promise<boolean> {\r\n    try {\r\n      await this.moduleRef.get(serviceType, { strict: false });\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all available services of a specific type\r\n   * Note: This is a basic implementation. For production use, consider using a service registry\r\n   */\r\n  async getAllServices<T>(serviceType: Type<T>): Promise<T[]> {\r\n    try {\r\n      // Try to get the service first to see if it exists\r\n      const service = await this.getService(serviceType);\r\n      return service ? [service] : [];\r\n    } catch (error) {\r\n      this.logger.debug(`No services of type ${serviceType.name} found: ${error.message}`);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resolve circular dependencies by using lazy loading\r\n   */\r\n  createLazyService<T>(serviceType: Type<T>): () => Promise<T> {\r\n    return async () => {\r\n      return await this.getService(serviceType);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create a service factory that can be used for conditional service creation\r\n   */\r\n  createServiceFactory<T>(\r\n    serviceType: Type<T>,\r\n    condition: () => boolean\r\n  ): () => Promise<T | null> {\r\n    return async () => {\r\n      if (condition()) {\r\n        return await this.getService(serviceType);\r\n      }\r\n      return null;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get service metadata for debugging purposes\r\n   */\r\n  getServiceMetadata(serviceType: Type<any>): any {\r\n    try {\r\n      const metadata = Reflect.getMetadata('design:paramtypes', serviceType) || [];\r\n      return {\r\n        name: serviceType.name,\r\n        parameters: metadata.map((param: any) => param?.name || 'unknown'),\r\n        isInjectable: Reflect.hasMetadata('injectable', serviceType),\r\n      };\r\n    } catch (error) {\r\n      this.logger.warn(`Failed to get metadata for service ${serviceType.name}: ${error.message}`);\r\n      return { name: serviceType.name, error: 'Failed to get metadata' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate service dependencies\r\n   */\r\n  async validateServiceDependencies(serviceType: Type<any>): Promise<{\r\n    isValid: boolean;\r\n    missingDependencies: string[];\r\n    errors: string[];\r\n  }> {\r\n    const result = {\r\n      isValid: true,\r\n      missingDependencies: [] as string[],\r\n      errors: [] as string[],\r\n    };\r\n\r\n    try {\r\n      const metadata = this.getServiceMetadata(serviceType);\r\n      const dependencies = metadata.parameters || [];\r\n\r\n      for (const dependency of dependencies) {\r\n        if (dependency === 'unknown') {\r\n          result.errors.push(`Unknown dependency type in ${serviceType.name}`);\r\n          result.isValid = false;\r\n          continue;\r\n        }\r\n\r\n        try {\r\n          // Try to resolve the dependency\r\n          const dependencyType = this.getDependencyType(dependency);\r\n          if (dependencyType) {\r\n            await this.getService(dependencyType);\r\n          }\r\n        } catch (error) {\r\n          result.missingDependencies.push(dependency);\r\n          result.isValid = false;\r\n        }\r\n      }\r\n    } catch (error) {\r\n      result.errors.push(`Failed to validate service ${serviceType.name}: ${error.message}`);\r\n      result.isValid = false;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Get dependency type from string name\r\n   * This is a simplified implementation - in practice, you might use a service registry\r\n   */\r\n  private getDependencyType(dependencyName: string): Type<any> | null {\r\n    // This would typically use a service registry or reflection\r\n    // For now, return null to indicate we can't determine the type\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Set cache entry with size management\r\n   */\r\n  private setCacheEntry(key: string, value: any): void {\r\n    if (!this.cacheEnabled) return;\r\n    \r\n    // Implement LRU-like behavior by removing oldest entries if cache is full\r\n    if (this.serviceCache.size >= this.maxCacheSize) {\r\n      const firstKey = this.serviceCache.keys().next().value;\r\n      if (firstKey) {\r\n        this.serviceCache.delete(firstKey);\r\n      }\r\n    }\r\n    \r\n    this.serviceCache.set(key, value);\r\n    this.logger.debug(`Service cached: ${key}`);\r\n  }\r\n\r\n  /**\r\n   * Clear service cache\r\n   */\r\n  clearCache(): void {\r\n    this.serviceCache.clear();\r\n    this.logger.debug('Service cache cleared');\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   */\r\n  getCacheStats(): { size: number; keys: string[]; maxSize: number; enabled: boolean } {\r\n    return {\r\n      size: this.serviceCache.size,\r\n      keys: Array.from(this.serviceCache.keys()),\r\n      maxSize: this.maxCacheSize,\r\n      enabled: this.cacheEnabled,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Enable or disable caching\r\n   */\r\n  setCacheEnabled(enabled: boolean): void {\r\n    (this as any).cacheEnabled = enabled;\r\n    if (!enabled) {\r\n      this.clearCache();\r\n    }\r\n    this.logger.debug(`Service caching ${enabled ? 'enabled' : 'disabled'}`);\r\n  }\r\n}\r\n"],"version":3}