{"file":"C:\\Users\\g-ekoh\\Desktop\\StrellerMinds-Backend\\src\\shared\\services\\redis.service.ts","mappings":";;;;;;;;;;;;;;;;AAAA,2CAA2E;AAC3E,2CAA+C;AAC/C,sDAA4B;AAE5B;;;GAGG;AAEI,IAAM,YAAY,GAAlB,MAAM,YAAY;IAGvB;;;OAGG;IACH,YAA6B,aAA4B;QAA5B,kBAAa,GAAb,aAAa,CAAe;IAAG,CAAC;IAE7D;;OAEG;IACH,YAAY;QACV,IAAI,CAAC,MAAM,GAAG,IAAI,iBAAK,CAAC;YACtB,IAAI,EAAE,IAAI,CAAC,aAAa,CAAC,GAAG,CAAS,kBAAkB,CAAC;YACxD,IAAI,EAAE,IAAI,CAAC,aAAa,CAAC,GAAG,CAAS,kBAAkB,CAAC;YACxD,QAAQ,EAAE,IAAI,CAAC,aAAa,CAAC,GAAG,CAAS,sBAAsB,CAAC;YAChE,EAAE,EAAE,IAAI,CAAC,aAAa,CAAC,GAAG,CAAS,gBAAgB,CAAC;SACrD,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACH,eAAe;QACb,IAAI,IAAI,CAAC,MAAM;YAAE,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;IACtC,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,GAAG,CAAC,GAAW,EAAE,KAAa,EAAE,UAAmB;QACvD,IAAI,UAAU,EAAE,CAAC;YACf,MAAM,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;QACtD,CAAC;aAAM,CAAC;YACN,MAAM,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QACpC,CAAC;IACH,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,GAAG,CAAC,GAAW;QACnB,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC9B,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,GAAG,CAAC,GAAW;QACnB,MAAM,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC7B,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,MAAM,CAAC,GAAW;QACtB,OAAO,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC;IAC/C,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,cAAc,CAAC,KAAa,EAAE,SAAiB;QACnD,MAAM,IAAI,CAAC,GAAG,CAAC,aAAa,KAAK,EAAE,EAAE,GAAG,EAAE,SAAS,CAAC,CAAC;IACvD,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,kBAAkB,CAAC,KAAa;QACpC,OAAO,IAAI,CAAC,MAAM,CAAC,aAAa,KAAK,EAAE,CAAC,CAAC;IAC3C,CAAC;CACF,CAAA;AArFY,oCAAY;uBAAZ,YAAY;IADxB,IAAA,mBAAU,GAAE;yDAQiC,sBAAa,oBAAb,sBAAa;GAP9C,YAAY,CAqFxB","names":[],"sources":["C:\\Users\\g-ekoh\\Desktop\\StrellerMinds-Backend\\src\\shared\\services\\redis.service.ts"],"sourcesContent":["import { Injectable, OnModuleInit, OnModuleDestroy } from '@nestjs/common';\r\nimport { ConfigService } from '@nestjs/config';\r\nimport Redis from 'ioredis';\r\n\r\n/**\r\n * Service for interacting with Redis, including caching and token blacklisting.\r\n * Handles connection lifecycle and provides utility methods for Redis operations.\r\n */\r\n@Injectable()\r\nexport class RedisService implements OnModuleInit, OnModuleDestroy {\r\n  private client: Redis;\r\n\r\n  /**\r\n   * Constructs the RedisService.\r\n   * @param configService - The configuration service for accessing Redis connection settings.\r\n   */\r\n  constructor(private readonly configService: ConfigService) {}\r\n\r\n  /**\r\n   * Initializes the Redis client connection on module init.\r\n   */\r\n  onModuleInit() {\r\n    this.client = new Redis({\r\n      host: this.configService.get<string>('cache.redis.host'),\r\n      port: this.configService.get<number>('cache.redis.port'),\r\n      password: this.configService.get<string>('cache.redis.password'),\r\n      db: this.configService.get<number>('cache.redis.db'),\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Closes the Redis client connection on module destroy.\r\n   */\r\n  onModuleDestroy() {\r\n    if (this.client) this.client.quit();\r\n  }\r\n\r\n  /**\r\n   * Set a value in Redis with optional TTL.\r\n   * @param key Redis key\r\n   * @param value Value to store\r\n   * @param ttlSeconds Optional time-to-live in seconds\r\n   */\r\n  async set(key: string, value: string, ttlSeconds?: number) {\r\n    if (ttlSeconds) {\r\n      await this.client.set(key, value, 'EX', ttlSeconds);\r\n    } else {\r\n      await this.client.set(key, value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a value from Redis by key.\r\n   * @param key Redis key\r\n   * @returns The value or null if not found\r\n   */\r\n  async get(key: string): Promise<string | null> {\r\n    return this.client.get(key);\r\n  }\r\n\r\n  /**\r\n   * Delete a key from Redis.\r\n   * @param key Redis key\r\n   */\r\n  async del(key: string) {\r\n    await this.client.del(key);\r\n  }\r\n\r\n  /**\r\n   * Check if a key exists in Redis.\r\n   * @param key Redis key\r\n   * @returns True if exists, false otherwise\r\n   */\r\n  async exists(key: string): Promise<boolean> {\r\n    return (await this.client.exists(key)) === 1;\r\n  }\r\n\r\n  /**\r\n   * Blacklist a token for a specified duration.\r\n   * @param token Token to blacklist\r\n   * @param expiresIn Expiry time in seconds\r\n   */\r\n  async blacklistToken(token: string, expiresIn: number) {\r\n    await this.set(`blacklist:${token}`, '1', expiresIn);\r\n  }\r\n\r\n  /**\r\n   * Check if a token is blacklisted.\r\n   * @param token Token to check\r\n   * @returns True if blacklisted, false otherwise\r\n   */\r\n  async isTokenBlacklisted(token: string): Promise<boolean> {\r\n    return this.exists(`blacklist:${token}`);\r\n  }\r\n}"],"version":3}