{"file":"C:\\Users\\g-ekoh\\Desktop\\StrellerMinds-Backend\\src\\ipfs\\ipfs.service.ts","mappings":";;;;;;;;;;;;;;;AAAA,2CAA4C;AAC5C,uDAA0C;AAC1C,4DAAoC;AACpC,mDAA8C;AAG9C;;GAEG;AAEI,IAAM,WAAW,GAAjB,MAAM,WAAW;IAItB;QACE,IAAI,CAAC,IAAI,GAAG,IAAA,yBAAM,EAAC;YACjB,GAAG,EAAE,oCAAoC;SAC1C,CAAC,CAAC;QACH,IAAI,CAAC,KAAK,GAAG,IAAI,oBAAS,CAAC,EAAE,MAAM,EAAE,GAAG,EAAE,WAAW,EAAE,GAAG,EAAE,CAAC,CAAC;IAChE,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,OAAO,CAAC,OAAe;QAC3B,IAAI,CAAC;YACH,MAAM,EAAE,GAAG,EAAE,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YAC7C,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,OAAO,CAAC,CAAC;YACxC,OAAO,GAAG,CAAC,QAAQ,EAAE,CAAC;QACxB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;QAC/C,CAAC;IACH,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,OAAO,CAAC,GAAW;QACvB,IAAI,CAAC;YACH,MAAM,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAC1C,IAAI,aAAa,EAAE,CAAC;gBAClB,OAAO,aAAa,CAAC,QAAQ,EAAE,CAAC;YAClC,CAAC;YAED,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAClC,IAAI,IAAI,GAAG,EAAE,CAAC;YAEd,IAAI,KAAK,EAAE,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;gBACjC,IAAI,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC;YAC3B,CAAC;YAED,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;YAC1B,OAAO,IAAI,CAAC;QACd,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;QACrD,CAAC;IACH,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,aAAa,CAAC,GAAW,EAAE,OAAe;QAC9C,MAAM,IAAI,GAAG,MAAM,IAAA,mBAAM,EAAC,OAAO,EAAE,EAAE,UAAU,EAAE,CAAC,EAAE,CAAC,CAAC;QACtD,OAAO,IAAI,KAAK,GAAG,CAAC;IACtB,CAAC;CACF,CAAA;AA9DY,kCAAW;sBAAX,WAAW;IADvB,IAAA,mBAAU,GAAE;;GACA,WAAW,CA8DvB","names":[],"sources":["C:\\Users\\g-ekoh\\Desktop\\StrellerMinds-Backend\\src\\ipfs\\ipfs.service.ts"],"sourcesContent":["import { Injectable } from '@nestjs/common';\r\nimport { create } from 'ipfs-http-client';\r\nimport NodeCache  from 'node-cache';\r\nimport { of as hashOf } from 'ipfs-only-hash';\r\nimport { ApiTags } from '@nestjs/swagger';\r\n\r\n/**\r\n * Service for interacting with IPFS: add, retrieve, and verify content.\r\n */\r\n@Injectable()\r\nexport class IpfsService {\r\n  private ipfs;\r\n  private cache: NodeCache;\r\n\r\n  constructor() {\r\n    this.ipfs = create({\r\n      url: 'https://ipfs.infura.io:5001/api/v0',\r\n    });\r\n    this.cache = new NodeCache({ stdTTL: 100, checkperiod: 120 });\r\n  }\r\n\r\n  /**\r\n   * Add a file to IPFS and cache it.\r\n   * @param content Buffer of the file content.\r\n   * @returns The CID of the stored content.\r\n   */\r\n  async addFile(content: Buffer): Promise<string> {\r\n    try {\r\n      const { cid } = await this.ipfs.add(content);\r\n      this.cache.set(cid.toString(), content);\r\n      return cid.toString();\r\n    } catch (error) {\r\n      throw new Error('Error adding file to IPFS');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieve a file from IPFS by CID, using cache if available.\r\n   * @param cid The Content Identifier.\r\n   * @returns The content as a string.\r\n   */\r\n  async getFile(cid: string): Promise<string> {\r\n    try {\r\n      const cachedContent = this.cache.get(cid);\r\n      if (cachedContent) {\r\n        return cachedContent.toString();\r\n      }\r\n\r\n      const stream = this.ipfs.cat(cid);\r\n      let data = '';\r\n\r\n      for await (const chunk of stream) {\r\n        data += chunk.toString();\r\n      }\r\n\r\n      this.cache.set(cid, data);\r\n      return data;\r\n    } catch (error) {\r\n      throw new Error('Error retrieving file from IPFS');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify that the content matches the given CID.\r\n   * @param cid The Content Identifier.\r\n   * @param content The content buffer to verify.\r\n   * @returns True if the content matches the CID, false otherwise.\r\n   */\r\n  async verifyContent(cid: string, content: Buffer): Promise<boolean> {\r\n    const hash = await hashOf(content, { cidVersion: 0 });\r\n    return hash === cid;\r\n  }\r\n}\r\n"],"version":3}