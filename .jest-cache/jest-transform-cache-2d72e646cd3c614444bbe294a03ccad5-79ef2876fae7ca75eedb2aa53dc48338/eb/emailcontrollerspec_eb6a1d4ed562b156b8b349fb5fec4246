a91939c02ce723dd422e512202b12ec1
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const testing_1 = require("@nestjs/testing");
const email_controller_1 = require("./email.controller");
const email_service_1 = require("./email.service");
describe('EmailController', () => {
    let controller;
    let mockService;
    beforeEach(async () => {
        mockService = {
            sendVerificationEmail: jest.fn(),
            updateEmailPreference: jest.fn(),
            getUserPreferences: jest.fn(),
        };
        const module = await testing_1.Test.createTestingModule({
            controllers: [email_controller_1.EmailController],
            providers: [{ provide: email_service_1.EmailService, useValue: mockService }],
        }).compile();
        controller = module.get(email_controller_1.EmailController);
    });
    it('should be defined', () => {
        expect(controller).toBeDefined();
    });
    it('should send verification email', async () => {
        const mockUser = { email: 'user@example.com', name: 'User' };
        mockService.sendVerificationEmail.mockResolvedValue(true);
        const result = await controller.sendVerification({
            user: mockUser,
            code: '1234',
            token: 'token123',
        });
        expect(result).toBe(true);
        expect(mockService.sendVerificationEmail).toHaveBeenCalledWith(mockUser, '1234', 'token123');
    });
    it('should update email preference', async () => {
        const dto = { email: 'user@example.com', type: 'email-verification', optOut: true };
        await controller.updatePreference(dto);
        expect(mockService.updateEmailPreference).toHaveBeenCalledWith('user@example.com', 'email-verification', true);
    });
    it('should get user preferences', async () => {
        const email = 'user@example.com';
        await controller.getPreferences(email);
        expect(mockService.getUserPreferences).toHaveBeenCalledWith(email);
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxnLWVrb2hcXERlc2t0b3BcXFN0cmVsbGVyTWluZHMtQmFja2VuZFxcc3JjXFxlbWFpbFxcZW1haWwuY29udHJvbGxlci5zcGVjLnRzIiwibWFwcGluZ3MiOiI7O0FBQUEsNkNBQXNEO0FBQ3RELHlEQUFxRDtBQUNyRCxtREFBK0M7QUFFL0MsUUFBUSxDQUFDLGlCQUFpQixFQUFFLEdBQUcsRUFBRTtJQUMvQixJQUFJLFVBQTJCLENBQUM7SUFDaEMsSUFBSSxXQUFrQyxDQUFDO0lBRXZDLFVBQVUsQ0FBQyxLQUFLLElBQUksRUFBRTtRQUNwQixXQUFXLEdBQUc7WUFDWixxQkFBcUIsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ2hDLHFCQUFxQixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDaEMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtTQUM5QixDQUFDO1FBRUYsTUFBTSxNQUFNLEdBQWtCLE1BQU0sY0FBSSxDQUFDLG1CQUFtQixDQUFDO1lBQzNELFdBQVcsRUFBRSxDQUFDLGtDQUFlLENBQUM7WUFDOUIsU0FBUyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsNEJBQVksRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLENBQUM7U0FDOUQsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRWIsVUFBVSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQWtCLGtDQUFlLENBQUMsQ0FBQztJQUM1RCxDQUFDLENBQUMsQ0FBQztJQUVILEVBQUUsQ0FBQyxtQkFBbUIsRUFBRSxHQUFHLEVBQUU7UUFDM0IsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ25DLENBQUMsQ0FBQyxDQUFDO0lBRUgsRUFBRSxDQUFDLGdDQUFnQyxFQUFFLEtBQUssSUFBSSxFQUFFO1FBQzlDLE1BQU0sUUFBUSxHQUFHLEVBQUUsS0FBSyxFQUFFLGtCQUFrQixFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQztRQUM1RCxXQUFXLENBQUMscUJBQW1DLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFekUsTUFBTSxNQUFNLEdBQUcsTUFBTSxVQUFVLENBQUMsZ0JBQWdCLENBQUM7WUFDL0MsSUFBSSxFQUFFLFFBQVE7WUFDZCxJQUFJLEVBQUUsTUFBTTtZQUNaLEtBQUssRUFBRSxVQUFVO1NBQ2xCLENBQUMsQ0FBQztRQUVILE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDL0YsQ0FBQyxDQUFDLENBQUM7SUFFSCxFQUFFLENBQUMsZ0NBQWdDLEVBQUUsS0FBSyxJQUFJLEVBQUU7UUFDOUMsTUFBTSxHQUFHLEdBQUcsRUFBRSxLQUFLLEVBQUUsa0JBQWtCLEVBQUUsSUFBSSxFQUFFLG9CQUFvQixFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsQ0FBQztRQUNwRixNQUFNLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN2QyxNQUFNLENBQUMsV0FBVyxDQUFDLHFCQUFxQixDQUFDLENBQUMsb0JBQW9CLENBQzVELGtCQUFrQixFQUNsQixvQkFBb0IsRUFDcEIsSUFBSSxDQUNMLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztJQUVILEVBQUUsQ0FBQyw2QkFBNkIsRUFBRSxLQUFLLElBQUksRUFBRTtRQUMzQyxNQUFNLEtBQUssR0FBRyxrQkFBa0IsQ0FBQztRQUNqQyxNQUFNLFVBQVUsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdkMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3JFLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxnLWVrb2hcXERlc2t0b3BcXFN0cmVsbGVyTWluZHMtQmFja2VuZFxcc3JjXFxlbWFpbFxcZW1haWwuY29udHJvbGxlci5zcGVjLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRlc3QsIFRlc3RpbmdNb2R1bGUgfSBmcm9tICdAbmVzdGpzL3Rlc3RpbmcnO1xyXG5pbXBvcnQgeyBFbWFpbENvbnRyb2xsZXIgfSBmcm9tICcuL2VtYWlsLmNvbnRyb2xsZXInO1xyXG5pbXBvcnQgeyBFbWFpbFNlcnZpY2UgfSBmcm9tICcuL2VtYWlsLnNlcnZpY2UnO1xyXG5cclxuZGVzY3JpYmUoJ0VtYWlsQ29udHJvbGxlcicsICgpID0+IHtcclxuICBsZXQgY29udHJvbGxlcjogRW1haWxDb250cm9sbGVyO1xyXG4gIGxldCBtb2NrU2VydmljZTogUGFydGlhbDxFbWFpbFNlcnZpY2U+O1xyXG5cclxuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcclxuICAgIG1vY2tTZXJ2aWNlID0ge1xyXG4gICAgICBzZW5kVmVyaWZpY2F0aW9uRW1haWw6IGplc3QuZm4oKSxcclxuICAgICAgdXBkYXRlRW1haWxQcmVmZXJlbmNlOiBqZXN0LmZuKCksXHJcbiAgICAgIGdldFVzZXJQcmVmZXJlbmNlczogamVzdC5mbigpLFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBtb2R1bGU6IFRlc3RpbmdNb2R1bGUgPSBhd2FpdCBUZXN0LmNyZWF0ZVRlc3RpbmdNb2R1bGUoe1xyXG4gICAgICBjb250cm9sbGVyczogW0VtYWlsQ29udHJvbGxlcl0sXHJcbiAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogRW1haWxTZXJ2aWNlLCB1c2VWYWx1ZTogbW9ja1NlcnZpY2UgfV0sXHJcbiAgICB9KS5jb21waWxlKCk7XHJcblxyXG4gICAgY29udHJvbGxlciA9IG1vZHVsZS5nZXQ8RW1haWxDb250cm9sbGVyPihFbWFpbENvbnRyb2xsZXIpO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnc2hvdWxkIGJlIGRlZmluZWQnLCAoKSA9PiB7XHJcbiAgICBleHBlY3QoY29udHJvbGxlcikudG9CZURlZmluZWQoKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ3Nob3VsZCBzZW5kIHZlcmlmaWNhdGlvbiBlbWFpbCcsIGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IG1vY2tVc2VyID0geyBlbWFpbDogJ3VzZXJAZXhhbXBsZS5jb20nLCBuYW1lOiAnVXNlcicgfTtcclxuICAgIChtb2NrU2VydmljZS5zZW5kVmVyaWZpY2F0aW9uRW1haWwgYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250cm9sbGVyLnNlbmRWZXJpZmljYXRpb24oe1xyXG4gICAgICB1c2VyOiBtb2NrVXNlcixcclxuICAgICAgY29kZTogJzEyMzQnLFxyXG4gICAgICB0b2tlbjogJ3Rva2VuMTIzJyxcclxuICAgIH0pO1xyXG5cclxuICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XHJcbiAgICBleHBlY3QobW9ja1NlcnZpY2Uuc2VuZFZlcmlmaWNhdGlvbkVtYWlsKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtb2NrVXNlciwgJzEyMzQnLCAndG9rZW4xMjMnKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ3Nob3VsZCB1cGRhdGUgZW1haWwgcHJlZmVyZW5jZScsIGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IGR0byA9IHsgZW1haWw6ICd1c2VyQGV4YW1wbGUuY29tJywgdHlwZTogJ2VtYWlsLXZlcmlmaWNhdGlvbicsIG9wdE91dDogdHJ1ZSB9O1xyXG4gICAgYXdhaXQgY29udHJvbGxlci51cGRhdGVQcmVmZXJlbmNlKGR0byk7XHJcbiAgICBleHBlY3QobW9ja1NlcnZpY2UudXBkYXRlRW1haWxQcmVmZXJlbmNlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcclxuICAgICAgJ3VzZXJAZXhhbXBsZS5jb20nLFxyXG4gICAgICAnZW1haWwtdmVyaWZpY2F0aW9uJyxcclxuICAgICAgdHJ1ZSxcclxuICAgICk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdzaG91bGQgZ2V0IHVzZXIgcHJlZmVyZW5jZXMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBlbWFpbCA9ICd1c2VyQGV4YW1wbGUuY29tJztcclxuICAgIGF3YWl0IGNvbnRyb2xsZXIuZ2V0UHJlZmVyZW5jZXMoZW1haWwpO1xyXG4gICAgZXhwZWN0KG1vY2tTZXJ2aWNlLmdldFVzZXJQcmVmZXJlbmNlcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoZW1haWwpO1xyXG4gIH0pO1xyXG59KTtcclxuIl0sInZlcnNpb24iOjN9