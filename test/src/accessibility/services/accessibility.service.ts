import { Injectable, Logger } from "@nestjs/common"
import type { Repository } from "typeorm"

import { type AccessibilityMetadata, ContentType, type AriaRole } from "../entities/accessibility-metadata.entity"
import type { ContentLabel } from "../entities/content-label.entity"
import type { AccessibilityLoggingService } from "./accessibility-logging.service"

export interface AccessibilityData {
  contentId: string
  contentType: ContentType
  altText?: string
  ariaLabel?: string
  ariaRole?: AriaRole
  title?: string
  description?: string
  languageCode?: string
  isDecorative?: boolean
  customAttributes?: Record<string, any>
}

export interface AccessibilityResponse {
  data: any
  accessibility: {
    metadata?: AccessibilityMetadata
    labels?: ContentLabel[]
    structure?: {
      headings?: Array<{ level: number; text: string; id?: string }>
      landmarks?: Array<{ role: string; label?: string }>
      skipLinks?: Array<{ href: string; text: string }>
    }
    navigation?: {
      breadcrumbs?: Array<{ text: string; href?: string; current?: boolean }>
      pagination?: {
        current: number
        total: number
        hasNext: boolean
        hasPrevious: boolean
      }
    }
    forms?: {
      fields?: Array<{
        id: string
        label: string
        type: string
        required: boolean
        errors?: string[]
        helpText?: string
      }>
      validation?: {
        hasErrors: boolean
        errorSummary?: string[]
      }
    }
    media?: {
      hasAudio: boolean
      hasVideo: boolean
      hasTranscript: boolean
      hasCaptions: boolean
      hasAudioDescription: boolean
    }
  }
}

@Injectable()
export class AccessibilityService {
  private readonly logger = new Logger(AccessibilityService.name)

  constructor(
    private readonly metadataRepository: Repository<AccessibilityMetadata>,
    private readonly labelRepository: Repository<ContentLabel>,
    private readonly loggingService: AccessibilityLoggingService,
  ) {}

  async createAccessibilityMetadata(data: AccessibilityData): Promise<AccessibilityMetadata> {
    try {
      const metadata = this.metadataRepository.create({
        ...data,
        languageCode: data.languageCode || "en",
        isDecorative: data.isDecorative || false,
        validationStatus: "pending",
      })

      const saved = await this.metadataRepository.save(metadata)

      this.logger.log(`Created accessibility metadata for content: ${data.contentId}`)
      return saved
    } catch (error) {
      this.logger.error(`Failed to create accessibility metadata: ${error.message}`, error.stack)
      throw error
    }
  }

  async updateAccessibilityMetadata(
    contentId: string,
    updates: Partial<AccessibilityData>,
  ): Promise<AccessibilityMetadata> {
    try {
      const existing = await this.metadataRepository.findOne({
        where: { contentId },
      })

      if (!existing) {
        throw new Error(`Accessibility metadata not found for content: ${contentId}`)
      }

      Object.assign(existing, updates)
      existing.validationStatus = "pending"

      const updated = await this.metadataRepository.save(existing)

      this.logger.log(`Updated accessibility metadata for content: ${contentId}`)
      return updated
    } catch (error) {
      this.logger.error(`Failed to update accessibility metadata: ${error.message}`, error.stack)
      throw error
    }
  }

  async getAccessibilityMetadata(contentId: string): Promise<AccessibilityMetadata | null> {
    try {
      return await this.metadataRepository.findOne({
        where: { contentId },
      })
    } catch (error) {
      this.logger.error(`Failed to get accessibility metadata: ${error.message}`, error.stack)
      return null
    }
  }

  async getContentLabels(contentId: string, contentType: string, languageCode = "en"): Promise<ContentLabel[]> {
    try {
      return await this.labelRepository.find({
        where: {
          contentId,
          contentType,
          languageCode,
        },
        order: { createdAt: "DESC" },
      })
    } catch (error) {
      this.logger.error(`Failed to get content labels: ${error.message}`, error.stack)
      return []
    }
  }

  async createContentLabel(
    contentId: string,
    contentType: string,
    labelType: ContentLabel["labelType"],
    labelText: string,
    options: {
      languageCode?: string
      context?: string
      isAutoGenerated?: boolean
      confidenceScore?: number
      source?: ContentLabel["source"]
    } = {},
  ): Promise<ContentLabel> {
    try {
      const label = this.labelRepository.create({
        contentId,
        contentType,
        labelType,
        labelText,
        languageCode: options.languageCode || "en",
        context: options.context,
        isAutoGenerated: options.isAutoGenerated || false,
        confidenceScore: options.confidenceScore,
        source: options.source || "manual",
      })

      const saved = await this.labelRepository.save(label)

      this.logger.log(`Created content label for ${contentType}:${contentId}`)
      return saved
    } catch (error) {
      this.logger.error(`Failed to create content label: ${error.message}`, error.stack)
      throw error
    }
  }

  async enhanceResponseWithAccessibility(
    data: any,
    options: {
      includeMetadata?: boolean
      includeLabels?: boolean
      includeStructure?: boolean
      includeNavigation?: boolean
      includeForms?: boolean
      includeMedia?: boolean
      languageCode?: string
    } = {},
  ): Promise<AccessibilityResponse> {
    const accessibility: AccessibilityResponse["accessibility"] = {}

    try {
      // Extract content IDs from response data
      const contentIds = this.extractContentIds(data)

      if (options.includeMetadata && contentIds.length > 0) {
        const metadata = await this.metadataRepository.find({
          where: contentIds.map((id) => ({ contentId: id })),
        })
        accessibility.metadata = metadata[0] // For simplicity, return first match
      }

      if (options.includeLabels && contentIds.length > 0) {
        const labels = await this.labelRepository.find({
          where: contentIds.map((id) => ({
            contentId: id,
            languageCode: options.languageCode || "en",
          })),
        })
        accessibility.labels = labels
      }

      if (options.includeStructure) {
        accessibility.structure = this.generateStructureInfo(data)
      }

      if (options.includeNavigation) {
        accessibility.navigation = this.generateNavigationInfo(data)
      }

      if (options.includeForms) {
        accessibility.forms = this.generateFormsInfo(data)
      }

      if (options.includeMedia) {
        accessibility.media = this.generateMediaInfo(data)
      }

      return { data, accessibility }
    } catch (error) {
      this.logger.error(`Failed to enhance response with accessibility: ${error.message}`, error.stack)
      return { data, accessibility }
    }
  }

  async validateAccessibilityCompliance(contentId: string): Promise<{
    isCompliant: boolean
    level: "A" | "AA" | "AAA"
    violations: Array<{
      rule: string
      severity: "low" | "medium" | "high" | "critical"
      description: string
      suggestion: string
    }>
    warnings: string[]
  }> {
    try {
      const metadata = await this.getAccessibilityMetadata(contentId)

      if (!metadata) {
        return {
          isCompliant: false,
          level: "A",
          violations: [
            {
              rule: "missing-metadata",
              severity: "high",
              description: "No accessibility metadata found",
              suggestion: "Add accessibility metadata for this content",
            },
          ],
          warnings: [],
        }
      }

      const violations = []
      const warnings = []

      // Check for alt text on images
      if (metadata.contentType === ContentType.IMAGE && !metadata.isDecorative && !metadata.altText) {
        violations.push({
          rule: "img-alt",
          severity: "high" as const,
          description: "Image missing alternative text",
          suggestion: "Add descriptive alt text for the image",
        })
      }

      // Check for proper heading structure
      if (metadata.contentType === ContentType.HEADING && !metadata.headingLevel) {
        violations.push({
          rule: "heading-level",
          severity: "medium" as const,
          description: "Heading missing level information",
          suggestion: "Specify the heading level (h1-h6)",
        })
      }

      // Check for form labels
      if (metadata.contentType === ContentType.FORM && !metadata.formLabels) {
        violations.push({
          rule: "form-labels",
          severity: "high" as const,
          description: "Form elements missing labels",
          suggestion: "Add proper labels for all form elements",
        })
      }

      // Check color contrast
      if (metadata.colorContrast && metadata.colorContrast.ratio < 4.5) {
        violations.push({
          rule: "color-contrast",
          severity: "medium" as const,
          description: "Insufficient color contrast ratio",
          suggestion: "Increase color contrast to meet WCAG AA standards (4.5:1)",
        })
      }

      // Determine compliance level
      const criticalViolations = violations.filter((v) => v.severity === "critical")
      const highViolations = violations.filter((v) => v.severity === "high")
      const mediumViolations = violations.filter((v) => v.severity === "medium")

      let level: "A" | "AA" | "AAA" = "AAA"
      let isCompliant = true

      if (criticalViolations.length > 0 || highViolations.length > 0) {
        level = "A"
        isCompliant = false
      } else if (mediumViolations.length > 0) {
        level = "AA"
      }

      // Update metadata with validation results
      metadata.validationStatus = isCompliant ? "valid" : "invalid"
      metadata.validationErrors = violations.map((v) => v.description)
      metadata.validationWarnings = warnings
      metadata.complianceLevel = level

      await this.metadataRepository.save(metadata)

      return { isCompliant, level, violations, warnings }
    } catch (error) {
      this.logger.error(`Failed to validate accessibility compliance: ${error.message}`, error.stack)
      throw error
    }
  }

  private extractContentIds(data: any): string[] {
    const ids: string[] = []

    if (typeof data === "object" && data !== null) {
      if (data.id) ids.push(data.id)
      if (data.contentId) ids.push(data.contentId)

      if (Array.isArray(data)) {
        data.forEach((item) => {
          ids.push(...this.extractContentIds(item))
        })
      } else {
        Object.values(data).forEach((value) => {
          if (typeof value === "object") {
            ids.push(...this.extractContentIds(value))
          }
        })
      }
    }

    return [...new Set(ids)] // Remove duplicates
  }

  private generateStructureInfo(data: any) {
    return {
      headings: this.extractHeadings(data),
      landmarks: this.extractLandmarks(data),
      skipLinks: this.generateSkipLinks(data),
    }
  }

  private generateNavigationInfo(data: any) {
    return {
      breadcrumbs: this.extractBreadcrumbs(data),
      pagination: this.extractPagination(data),
    }
  }

  private generateFormsInfo(data: any) {
    return {
      fields: this.extractFormFields(data),
      validation: this.extractValidationInfo(data),
    }
  }

  private generateMediaInfo(data: any) {
    return {
      hasAudio: this.hasAudioContent(data),
      hasVideo: this.hasVideoContent(data),
      hasTranscript: this.hasTranscript(data),
      hasCaptions: this.hasCaptions(data),
      hasAudioDescription: this.hasAudioDescription(data),
    }
  }

  private extractHeadings(data: any): Array<{ level: number; text: string; id?: string }> {
    // Implementation would extract heading information from data
    return []
  }

  private extractLandmarks(data: any): Array<{ role: string; label?: string }> {
    // Implementation would extract landmark information from data
    return []
  }

  private generateSkipLinks(data: any): Array<{ href: string; text: string }> {
    // Implementation would generate appropriate skip links
    return [
      { href: "#main-content", text: "Skip to main content" },
      { href: "#navigation", text: "Skip to navigation" },
    ]
  }

  private extractBreadcrumbs(data: any): Array<{ text: string; href?: string; current?: boolean }> {
    // Implementation would extract breadcrumb information
    return []
  }

  private extractPagination(data: any) {
    // Implementation would extract pagination information
    if (data.pagination) {
      return {
        current: data.pagination.page || 1,
        total: data.pagination.totalPages || 1,
        hasNext: data.pagination.hasNext || false,
        hasPrevious: data.pagination.hasPrevious || false,
      }
    }
    return null
  }

  private extractFormFields(data: any) {
    // Implementation would extract form field information
    return []
  }

  private extractValidationInfo(data: any) {
    // Implementation would extract validation information
    return {
      hasErrors: false,
      errorSummary: [],
    }
  }

  private hasAudioContent(data: any): boolean {
    // Implementation would check for audio content
    return false
  }

  private hasVideoContent(data: any): boolean {
    // Implementation would check for video content
    return false
  }

  private hasTranscript(data: any): boolean {
    // Implementation would check for transcript availability
    return false
  }

  private hasCaptions(data: any): boolean {
    // Implementation would check for captions availability
    return false
  }

  private hasAudioDescription(data: any): boolean {
    // Implementation would check for audio description availability
    return false
  }
}
